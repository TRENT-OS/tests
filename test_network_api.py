import pytest

import sys
sys.path.append('../common')

import logs
import os
import re
import time
import socket

test_system = "test_network_api"
timeout = 180

def test_network_api_client(boot_with_proxy):

    test_run = boot_with_proxy(test_system)
    f_out = test_run[1]
    success = 'Client app read completed'
    (text, match) = logs.get_match_in_line(f_out, re.compile(success), timeout)
    print(text)
    assert match == success

def test_network_api_fsm_recovery(boot_with_proxy):

    test_run = boot_with_proxy(boot_with_proxy(test_system))
    f_out = test_run[1]

    # send a first chunk that will be sent back in chunks of the maximum
    # possible size
    with open('./test_network_api/dante.txt', 'rb') as file:
        blob = file.read(16)
    run_echo_client(blob)
    # send a second chunk that will be sent in bytes one by one. This means that
    # a lot of acks will be generated by this clients that they need to be
    # processd by the SEOS server that is also busy sending the echo. This
    # usually leads to the situation of chanmux overflow that needs to be
    # recovered. If that is recovered the following two steps after this one
    # will have to work correctly.
    # This step will be overtaken by the timeout on the socket.
    with open('./test_network_api/dante.txt', 'rb') as file:
        blob = file.read(1024)
    run_echo_client(blob)
    success = 'ChanMux FIFO will be reset'
    (text, match) = logs.get_match_in_line(f_out, re.compile(success), timeout)
    print(text)
    assert match == success

    with open('./test_network_api/dante.txt', 'rb') as file:
        blob = file.read(16)
    received_blob = run_echo_client(blob)
    assert received_blob == blob

    with open('./test_network_api/dante.txt', 'rb') as file:
        blob = file.read(16)
    received_blob = run_echo_client(blob)
    assert received_blob == blob

lst = [ 1024, 2048, 4096, 8192 ]
@pytest.mark.parametrize('n', lst)
def test_network_api_echo_server(boot_with_proxy, n):

    test_run = boot_with_proxy(boot_with_proxy(test_system))
    f_out = test_run[1]
    with open('./test_network_api/dante.txt', 'rb') as file:
        blob = file.read(n)
    received_blob = run_echo_client(blob)
    assert received_blob == blob

    success = 'Closing server socket communication'
    (text, match) = logs.get_match_in_line(f_out, re.compile(success), timeout)
    print(text)
    assert match == success

lst = [ 64, 128, 256, 512 ]
@pytest.mark.parametrize('n', lst)
def test_network_api_echo_server_1b1(boot_with_proxy, n):

    test_run = boot_with_proxy(boot_with_proxy(test_system))
    f_out = test_run[1]
    with open('./test_network_api/dante.txt', 'rb') as file:
        blob = file.read(n)
    received_blob = run_echo_client(blob)
    assert received_blob == blob

    success = 'Closing server socket communication'
    (text, match) = logs.get_match_in_line(f_out, re.compile(success), timeout)
    print(text)
    assert match == success

def run_echo_client(blob):

    print("Running tap app to connect to Server")

    server_address = ('192.168.82.92', 5555)
    received_blob = b""

    # Create a TCP/IP socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    if (sock != None):
        sock.settimeout(timeout)
    else:
        pytest.skip("could not get a socket")

    for attempt in range(3):
        print ('Trying to connect to Server, attemp # ' + str(attempt) + '...')

        try:
            # Connect the socket to the port where the server is listening
            print('connecting to %s port %s' %server_address, file=sys.stderr)
            sock.connect(server_address)
        except:
            print('connection failed, retrying in 2 secs')
            time.sleep(2)
            continue
        break

    try:
        # Send data
        print('sending blob of ' + str(len(blob)) + ' bytes', file=sys.stderr)
        test_time_base = time.time()
        sock.sendall(blob)

        # Look for the response
        while len(received_blob) < len(blob):
            received_blob += sock.recv(1)

            if (len(received_blob) == 1):
                time_leapsed_ms = (time.time() - test_time_base) * 1000
                print('first byte received in ' + str(time_leapsed_ms) + ' ms, troughtput (partial) is ' + str((len(blob) + 1) / time_leapsed_ms) + ' kB/s')

        time_leapsed_ms = (time.time() - test_time_base) * 1000
        print('echo completed in ' + str(time_leapsed_ms) + ' ms, troughtput (full echo) is ' + str((len(blob) * 2) / time_leapsed_ms) + ' kB/s')

    finally:
        print('closing socket', file=sys.stderr)
        sock.close()
        return received_blob
